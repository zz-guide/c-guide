#IPC（Inter-Process Communication，进程间通信）的几种方式

(1) 半双工Unix管道
本地socket,省去一些tcp的网络开销

(2) pipe
所谓的管道，就是内核里面的一串缓存
创建的子进程会复制父进程的文件描述符
pipe的限制有两个：

只能用于父子进程等有关联的进程之间来通信
pipe是单工的，如果要相互通信，需要开两个管道
对于匿名管道，它的通信范围是存在父子关系的进程 —— 生命周期随进程 匿名管道只存在内存中，不在文件系统中；无格式的流，大小受限，单向
效率低下

(3) FIFOs(命名管道)
FIFO(First In First Out)，又称为有名管道，弥补了管道只能用于有共同祖先的进程间通信的不足，相对于pipe，fifo主要有以下几个优点：

可以用于任意进程之间通信
可以有多个读/写进程同时对管道进行操作
可以像普通文件一样管理管道的权限
可以使用标准文件读写方式来操作管道(打开，读/写，关闭)

(3) 消息队列
消息队列是保存在内核中的消息链表 —— 生命周期随内核（系统）
一是通信不及时，二是附件也有大小限制，三是消息队列通信过程中，存在用户态与内核态之间的数据拷贝开销
消息队列不适合比较大数据的传输
MSGMAX 和 MSGMNB – 一条消息的最大长度和一个队列的最大长度

(4) 信号量
信号量其实是一个整型的计数器，主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据
P/V操作：P-信号量减1，V-信号量+1
V:相加后如果信号量 <= 0，则表明当前有阻塞中的进程，于是会将该进程唤醒运行；相加后如果信号量 > 0，则表明当前没有阻塞中的进程；
信号初始化为1：互斥信号量
信号初始化为0：同步信号量
——常规工作状态下的模式
(5) 共享内存

共享内存是进程间通信中最简单的方式之一。共享内存允许两个或更多进程访问同一块内存，就如同 malloc() 函数向不同进程返回了指向同一个物理内存区域的指针。当一个进程改变了这块地址中的内容的时候，其它进程都会察觉到这个更改。

函数ftok把一个已存在的路径名和一个整数标识符转换成一个key_t值，称为IPC键值（也称IPC key键值）。

ftok() shmget() shmat() shmdt() shmctl()

Linux命令【ipcs】可查看共享内存信息
Linux命令【ipcrm -m shmid】删除shmid的值的共享内存

(5) 信号
信号和信号量完全不是一个东西
信号是进程间通信机制中 唯一 的 异步通信机制！！ 可以在任何时候发送信号给某一进程
用户进程或目标进程对信号的处理方式：
1.执行默认操作 2.捕捉信号 3.忽略信号（但 SIGKILL 和 SEGSTOP 2个信号是进程无法捕捉和忽略的，可用于在任何时刻结束或者中断进程）


(6) 网络Socket


各种通信方式的比较和优缺点：
管道：速度慢，容量有限，只有父子进程能通讯

FIFO：任何进程间都能通讯，但速度慢

消息队列：容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题

信号量：不能传递复杂消息，只能用来同步

共享内存区：能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了同一进程内的一块内存